%%===============================================================================%%
%%% @author SaveMos
%%% @copyright (C) 2025, <FleetFra>
%%% @doc
%%%
%%% This module implements a simple user handler that interacts with
%%% WebSocket clients for a game. It handles player-specific actions
%%% by using a `gen_server` behavior to start and manage player
%%% handler processes, send messages, and update the game state.
%%%
%%% @end
%%% Created : 07. feb 2025 10:18
%%===============================================================================%%

-module(fleetfra_chin_user_handler).
-author("SaveMos").
-behaviour(gen_server).

%%%-------------------------------------------------------------------
%%% Exported API Functions
%%%-------------------------------------------------------------------

-export([start_link/2, send_message/2]).

%%%-------------------------------------------------------------------
%%% gen_server Callbacks
%%%-------------------------------------------------------------------

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

%%%===================================================================
%%% API Functions
%%%===================================================================
%%-------------------------------------------------------------------
%% @doc
%% Starts a user handler process and registers it under a unique name.
%% The name is generated by concatenating the GameID and PlayerID.
%%
%% @param GameID - The unique identifier for the game.
%% @param PlayerID - The unique identifier for the player.
%%
%% @returns {ok, pid} - The result of starting the user handler process.
%% @end
%%-------------------------------------------------------------------
start_link(GameID, PlayerID) ->
  %% Generate a unique name for the player by combining GameID and PlayerID
  Name = utility:concat_game_player(GameID, PlayerID),
  %% Start the gen_server and register the process locally under the generated name
  gen_server:start_link({local, Name}, ?MODULE, [GameID, PlayerID], []).

%%-------------------------------------------------------------------
%% @doc
%% Sends a message to the user handler process. This message will be
%% forwarded to the WebSocket client for that player.
%%
%% @param Name - The unique name of the player (generated as GameID_PlayerID).
%% @param Msg - The message to be sent to the player.
%%
%% @returns {ok, Msg} - Confirmation that the message was sent.
%% @end
%%-------------------------------------------------------------------
send_message(Name, Msg) ->
  %% Send a cast message to the gen_server, which will handle forwarding it
  gen_server:cast(Name, {send, Msg}).

%%%===================================================================
%%% gen_server Callbacks
%%%===================================================================

%%-------------------------------------------------------------------
%% @doc
%% Initializes the user handler process. It ensures the process is
%% registered under the correct name and stores the game and player IDs
%% in the state.
%%
%% @param [GameID, PlayerID] - The initial arguments for the game and player.
%%
%% @returns {ok, State} - The initial state of the gen_server with the game and player information.
%% @end
%%-------------------------------------------------------------------
init([GameID, PlayerID]) ->
  %% Generate a unique name for the player
  Name = utility:concat_game_player(GameID, PlayerID),

  %% If the process with the same name already exists, unregister it
  case erlang:whereis(Name) of
    undefined -> pass; %% No action if the process is not already registered
    _ -> erlang:unregister(Name) %% Unregister if the process is already registered
  end,

  %% Register this process under the generated name
  erlang:register(Name, erlang:self()),

  %% Return the initial state containing the game and player IDs
  {ok, #{ game_id => GameID, player_id => PlayerID }}.

%%-------------------------------------------------------------------
%% @doc
%% Handles synchronous calls to the gen_server. Currently, it just replies
%% with `ok` and does not perform any specific actions for the requests.
%%
%% @param _Request - The request received by the gen_server.
%% @param _From - Information about the sender of the request.
%% @param State - The current state of the gen_server.
%%
%% @returns {reply, ok, State} - A simple acknowledgement with no state change.
%% @end
%%-------------------------------------------------------------------
handle_call(_Request, _From, State) ->
  {reply, ok, State}.

%%-------------------------------------------------------------------
%% @doc
%% Handles asynchronous casts sent to the gen_server. Specifically, this
%% handler listens for the `{send, Msg}` message, prints the received
%% message, and then forwards the message to a WebSocket client in JSON format.
%%
%% @param {send, Msg} - The message containing the game update to be forwarded.
%% @param State - The current state of the gen_server.
%%
%% @returns {{text, JsonMessage}, Msg} - The response to be forwarded to the client.
%% @end
%%-------------------------------------------------------------------
handle_cast({send, Msg}, State) ->
  %% Log the received message
  io:format("USER-HANDLER: Player2 received game update: ~p ~p ~n", [Msg, State]),

  %% Convert the message to a JSON format with a "game_update" type
  JsonMessage = jsx:encode([{<<"type">>, game_update}, {<<"msg">>, Msg}]),

  %% Return the message and forward it to the WebSocket client
  {{text, JsonMessage}, Msg, State}.

%%-------------------------------------------------------------------
%% @doc
%% Handles any information sent to the gen_server that does not match
%% the `call` or `cast` patterns. In this case, it just ignores the message
%% and returns the current state.
%%
%% @param _Info - The info received by the gen_server.
%% @param State - The current state of the gen_server.
%%
%% @returns {noreply, State} - No reply is sent, and the state is unchanged.
%% @end
%%-------------------------------------------------------------------
handle_info(_Info, State) ->
  {noreply, State}.

%%-------------------------------------------------------------------
%% @doc
%% Terminates the gen_server process. This function is a no-op as the
%% process does not require any specific termination logic.
%%
%% @param _Reason - The reason for termination.
%% @param _State - The state at the time of termination.
%%
%% @returns ok - A simple acknowledgement that the process is terminating.
%% @end
%%-------------------------------------------------------------------
terminate(_Reason, _State) ->
  ok.

%%-------------------------------------------------------------------
%% @doc
%% Handles code changes when the system is upgraded. This function is
%% implemented to return the state as-is, since the module does not perform
%% any special handling during code upgrades.
%%
%% @param _OldVsn - The old version of the code.
%% @param State - The current state of the gen_server.
%% @param _Extra - Extra parameters related to the upgrade.
%%
%% @returns {ok, State} - Return the current state unchanged.
%% @end
%%-------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.
